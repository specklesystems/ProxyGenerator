[
  {
    HintName: ProxyInterfaceSourceGeneratorTests.Source.IMyStruct.g.cs,
    Source:
//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by https://github.com/specklesystems/ProxyGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------

#nullable enable
using System;

namespace ProxyInterfaceSourceGeneratorTests.Source
{
    public partial interface IMyStruct
    {
        global::ProxyInterfaceSourceGeneratorTests.Source.MyStruct _Instance { get; }

        int Id { get; set; }

        bool TryGetMyStruct2(int i, out global::ProxyInterfaceSourceGeneratorTests.Source.MyStruct2 x, double z);
    }
}
#nullable restore
  },
  {
    HintName: ProxyInterfaceSourceGeneratorTests.Source.IMyStruct2.g.cs,
    Source:
//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by https://github.com/specklesystems/ProxyGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------

#nullable enable
using System;

namespace ProxyInterfaceSourceGeneratorTests.Source
{
    public partial interface IMyStruct2
    {
        global::ProxyInterfaceSourceGeneratorTests.Source.MyStruct2 _Instance { get; }

        int Id { get; set; }


    }
}
#nullable restore
  },
  {
    HintName: ProxyInterfaceSourceGeneratorTests.Source.MyStructProxy.g.cs,
    Source:
//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by https://github.com/specklesystems/ProxyGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------

#nullable enable
using System;

namespace ProxyInterfaceSourceGeneratorTests.Source
{
    public partial struct MyStructProxy : global::ProxyInterfaceSourceGeneratorTests.Source.IMyStruct
    {
        public global::ProxyInterfaceSourceGeneratorTests.Source.MyStruct _Instance { get; }
        
        public int Id { get => _Instance.Id; }

        public bool TryGetMyStruct2(int i, out global::ProxyInterfaceSourceGeneratorTests.Source.IMyStruct2 x, double z)
        {
            int i_ = i;
            global::ProxyInterfaceSourceGeneratorTests.Source.MyStruct2 x_;
            double z_ = z;
            var result_222455096 = _Instance.TryGetMyStruct2(i_, out x_, z_);
            x = Mapster.TypeAdapter.Adapt<global::ProxyInterfaceSourceGeneratorTests.Source.IMyStruct2>(x_);
            return result_222455096;
        }


        public MyStructProxy(global::ProxyInterfaceSourceGeneratorTests.Source.MyStruct instance)
        {
            _Instance = instance;
            
        }

        static MyStructProxy()
        {
            Mapster.TypeAdapterConfig<global::ProxyInterfaceSourceGeneratorTests.Source.MyStruct2, global::ProxyInterfaceSourceGeneratorTests.Source.IMyStruct2>.NewConfig().ConstructUsing(instance_1687574103 => new global::ProxyInterfaceSourceGeneratorTests.Source.MyStruct2Proxy(instance_1687574103));
            Mapster.TypeAdapterConfig<global::ProxyInterfaceSourceGeneratorTests.Source.IMyStruct2, global::ProxyInterfaceSourceGeneratorTests.Source.MyStruct2>.NewConfig().MapWith(proxy_1070335295 => ((global::ProxyInterfaceSourceGeneratorTests.Source.MyStruct2Proxy) proxy_1070335295)._Instance);
        }
            
    }
}
#nullable restore
  },
  {
    HintName: ProxyInterfaceSourceGeneratorTests.Source.MyStruct2Proxy.g.cs,
    Source:
//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by https://github.com/specklesystems/ProxyGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------

#nullable enable
using System;

namespace ProxyInterfaceSourceGeneratorTests.Source
{
    public partial struct MyStruct2Proxy : global::ProxyInterfaceSourceGeneratorTests.Source.IMyStruct2
    {
        public global::ProxyInterfaceSourceGeneratorTests.Source.MyStruct2 _Instance { get; }
        
        public int Id { get => _Instance.Id; }


        public MyStruct2Proxy(global::ProxyInterfaceSourceGeneratorTests.Source.MyStruct2 instance)
        {
            _Instance = instance;
            
        }

        static MyStruct2Proxy()
        {
            Mapster.TypeAdapterConfig<global::ProxyInterfaceSourceGeneratorTests.Source.MyStruct2, global::ProxyInterfaceSourceGeneratorTests.Source.IMyStruct2>.NewConfig().ConstructUsing(instance_1687574103 => new global::ProxyInterfaceSourceGeneratorTests.Source.MyStruct2Proxy(instance_1687574103));
            Mapster.TypeAdapterConfig<global::ProxyInterfaceSourceGeneratorTests.Source.IMyStruct2, global::ProxyInterfaceSourceGeneratorTests.Source.MyStruct2>.NewConfig().MapWith(proxy_1070335295 => ((global::ProxyInterfaceSourceGeneratorTests.Source.MyStruct2Proxy) proxy_1070335295)._Instance);
        }
            
    }
}
#nullable restore
  },
  {
    HintName: Speckle.ProxyGenerator.Extra.g.cs,
    Source:
//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by https://github.com/specklesystems/ProxyGenerator
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------

#nullable enable
using System;

namespace Speckle.ProxyGenerator
{
    [AttributeUsage(AttributeTargets.Interface)]
    internal sealed class ProxyAttribute : Attribute
    {
        public Type Type { get; }
        public ImplementationOptions Options { get; }
        public ProxyClassAccessibility Accessibility { get; }
        public string[]? MembersToIgnore { get; }

        public ProxyAttribute(Type type) : this(type, ImplementationOptions.None, ProxyClassAccessibility.Public)
        {
        }

        public ProxyAttribute(Type type, ImplementationOptions options) : this(type, options, ProxyClassAccessibility.Public)
        {
        }

       	public ProxyAttribute(Type type, ProxyClassAccessibility accessibility) : this(type, ImplementationOptions.None, accessibility)
        {
        }

        public ProxyAttribute(Type type, ImplementationOptions options, ProxyClassAccessibility accessibility) : this(type, options, accessibility, null)
        {
        }

        public ProxyAttribute(Type type, string[]? membersToIgnore) : this(type, ImplementationOptions.None, ProxyClassAccessibility.Public, null)
        {
        }

        public ProxyAttribute(Type type, ImplementationOptions options, string[]? membersToIgnore) : this(type, options, ProxyClassAccessibility.Public, null)
        {
        }

        public ProxyAttribute(Type type, ImplementationOptions options, ProxyClassAccessibility accessibility, string[]? membersToIgnore)
        {
            Type = type;
            Options = options;
            Accessibility = accessibility;
            MembersToIgnore = membersToIgnore;
        }
    }

    [Flags]
    internal enum ProxyClassAccessibility
    {
        Public = 0,

        Internal = 1
    }
    [Flags]
    internal enum ImplementationOptions
    {
        None = 0,

        ProxyBaseClasses = 1,

        ProxyInterfaces = 2,

        UseExtendedInterfaces = 4,

        ProxyForBaseInterface = 8
    }

    public static class ProxyMap
    {
      private static readonly global::System.Collections.Concurrent.ConcurrentDictionary<Type, Type> s_revitToInterfaceMap = new();
      private static readonly global::System.Collections.Concurrent.ConcurrentDictionary<Type, Type> s_proxyToInterfaceMap = new();
      private static readonly global::System.Collections.Concurrent.ConcurrentDictionary<Type, Type> s_interfaceToRevit = new();
      private static readonly global::System.Collections.Concurrent.ConcurrentDictionary<Type, Func<object, object>> s_proxyFactory = new();

      static ProxyMap()
      {
        Add<ProxyInterfaceSourceGeneratorTests.Source.MyStruct, global::ProxyInterfaceSourceGeneratorTests.Source.IMyStruct, ProxyInterfaceSourceGeneratorTests.Source.MyStructProxy>(x => new ProxyInterfaceSourceGeneratorTests.Source.MyStructProxy(x));
Add<ProxyInterfaceSourceGeneratorTests.Source.MyStruct2, global::ProxyInterfaceSourceGeneratorTests.Source.IMyStruct2, ProxyInterfaceSourceGeneratorTests.Source.MyStruct2Proxy>(x => new ProxyInterfaceSourceGeneratorTests.Source.MyStruct2Proxy(x));

      }

      private static void Add<T, TInterface, TProxy>(Func<T, TProxy> f)
        where TInterface : notnull
        where TProxy : TInterface
      {
        s_revitToInterfaceMap.TryAdd(typeof(T), typeof(TInterface));
        s_proxyToInterfaceMap.TryAdd(typeof(TProxy), typeof(TInterface));
        s_proxyFactory.TryAdd(typeof(TInterface), w => f((T)w));
        s_interfaceToRevit.TryAdd(typeof(TInterface), typeof(T));
      }

      public static Type? GetMappedTypeFromHostType(Type type)
      {
        if (s_revitToInterfaceMap.TryGetValue(type, out var t))
        {
          return t;
        }
        return null;
      }

      public static Type? GetMappedTypeFromProxyType(Type type)
      {
        if (s_proxyToInterfaceMap.TryGetValue(type, out var t))
        {
          return t;
        }

        return null;
      }

      public static Type? GetHostTypeFromMappedType(Type type)
      {
        if (s_interfaceToRevit.TryGetValue(type, out var t))
        {
          return t;
        }

        return null;
      }

      public static object CreateProxy(Type type, object toWrap) => s_proxyFactory[type](toWrap);
      public static T CreateProxy<T>(object toWrap) => (T)CreateProxy(typeof(T), toWrap);
    }
#nullable restore
}
  }
]